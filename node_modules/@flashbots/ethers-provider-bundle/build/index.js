"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlashbotsBundleProvider = exports.FlashbotsBundleResolution = exports.DEFAULT_FLASHBOTS_RELAY = void 0;
const ethers_1 = require("ethers");
exports.DEFAULT_FLASHBOTS_RELAY = 'https://relay.flashbots.net';
var FlashbotsBundleResolution;
(function (FlashbotsBundleResolution) {
    FlashbotsBundleResolution[FlashbotsBundleResolution["BundleIncluded"] = 0] = "BundleIncluded";
    FlashbotsBundleResolution[FlashbotsBundleResolution["BlockPassedWithoutInclusion"] = 1] = "BlockPassedWithoutInclusion";
    FlashbotsBundleResolution[FlashbotsBundleResolution["AccountNonceTooHigh"] = 2] = "AccountNonceTooHigh";
})(FlashbotsBundleResolution = exports.FlashbotsBundleResolution || (exports.FlashbotsBundleResolution = {}));
const TIMEOUT_MS = 5 * 60 * 1000;
const SECONDS_PER_BLOCK = 15;
class FlashbotsBundleProvider extends ethers_1.providers.JsonRpcProvider {
    constructor(genericProvider, connectionInfoOrUrl, network) {
        super(connectionInfoOrUrl, network);
        this.genericProvider = genericProvider;
    }
    static async throttleCallback() {
        console.warn('Rate limited');
        return false;
    }
    static async create(genericProvider, flashbotsKeyId, flashbotsSecret, connectionInfoOrUrl, network) {
        const connectionInfo = typeof connectionInfoOrUrl === 'string' || typeof connectionInfoOrUrl === 'undefined'
            ? {
                url: connectionInfoOrUrl || exports.DEFAULT_FLASHBOTS_RELAY
            }
            : {
                ...connectionInfoOrUrl
            };
        if (connectionInfo.headers === undefined)
            connectionInfo.headers = {};
        connectionInfo.headers.Authorization = `${flashbotsKeyId}:${flashbotsSecret}`;
        connectionInfo.throttleCallback = FlashbotsBundleProvider.throttleCallback;
        const networkish = {
            chainId: 0,
            name: ''
        };
        if (typeof network === 'string') {
            networkish.name = network;
        }
        else if (typeof network === 'number') {
            networkish.chainId = network;
        }
        else if (typeof network === 'object') {
            networkish.name = network.name;
            networkish.chainId = network.chainId;
        }
        if (networkish.chainId === 0) {
            networkish.chainId = (await genericProvider.getNetwork()).chainId;
        }
        return new FlashbotsBundleProvider(genericProvider, connectionInfo, networkish);
    }
    async sendRawBundle(signedBundledTransactions, targetBlockNumber, opts) {
        await this.send('eth_sendBundle', [
            signedBundledTransactions,
            `0x${targetBlockNumber.toString(16)}`,
            (opts === null || opts === void 0 ? void 0 : opts.minTimestamp) || 0,
            (opts === null || opts === void 0 ? void 0 : opts.maxTimestamp) || 0
        ]);
        const bundleTransactions = signedBundledTransactions.map((signedTransaction) => {
            const transactionDetails = ethers_1.ethers.utils.parseTransaction(signedTransaction);
            return {
                signedTransaction,
                hash: ethers_1.ethers.utils.keccak256(signedTransaction),
                account: transactionDetails.from || '0x0',
                nonce: transactionDetails.nonce
            };
        });
        return {
            bundleTransactions,
            wait: () => this.wait(bundleTransactions, targetBlockNumber, TIMEOUT_MS),
            simulate: () => this.simulate(bundleTransactions.map((tx) => tx.signedTransaction), targetBlockNumber),
            receipts: () => this.fetchReceipts(bundleTransactions)
        };
    }
    async sendBundle(bundledTransactions, targetBlockNumber, opts) {
        const signedTransactions = await this.signBundle(bundledTransactions);
        return this.sendRawBundle(signedTransactions, targetBlockNumber, opts);
    }
    async signBundle(bundledTransactions) {
        const nonces = {};
        const signedTransactions = new Array();
        for (const tx of bundledTransactions) {
            if ('signedTransaction' in tx) {
                // in case someone is mixing pre-signed and signing transactions, decode to add to nonce object
                const transactionDetails = ethers_1.ethers.utils.parseTransaction(tx.signedTransaction);
                if (transactionDetails.from === undefined)
                    throw new Error('Could not decode signed transaction');
                nonces[transactionDetails.from] = ethers_1.BigNumber.from(transactionDetails.nonce + 1);
                signedTransactions.push(tx.signedTransaction);
                continue;
            }
            const transaction = { ...tx.transaction };
            const address = await tx.signer.getAddress();
            if (typeof transaction.nonce === 'string')
                throw new Error('Bad nonce');
            const nonce = transaction.nonce !== undefined
                ? ethers_1.BigNumber.from(transaction.nonce)
                : nonces[address] || ethers_1.BigNumber.from(await this.genericProvider.getTransactionCount(address, 'latest'));
            nonces[address] = nonce.add(1);
            if (transaction.nonce === undefined)
                transaction.nonce = nonce;
            if (transaction.gasPrice === undefined)
                transaction.gasPrice = ethers_1.BigNumber.from(0);
            if (transaction.gasLimit === undefined)
                transaction.gasLimit = await tx.signer.estimateGas(transaction); // TODO: Add target block number and timestamp when supported by geth
            signedTransactions.push(await tx.signer.signTransaction(transaction));
        }
        return signedTransactions;
    }
    wait(transactionAccountNonces, targetBlockNumber, timeout) {
        return new Promise((resolve, reject) => {
            let timer = null;
            let done = false;
            const minimumNonceByAccount = transactionAccountNonces.reduce((acc, accountNonce) => {
                if (accountNonce.nonce > 0 && (accountNonce.nonce || 0) < acc[accountNonce.account]) {
                    acc[accountNonce.account] = accountNonce.nonce;
                }
                acc[accountNonce.account] = accountNonce.nonce;
                return acc;
            }, {});
            const handler = async (blockNumber) => {
                if (blockNumber < targetBlockNumber) {
                    const noncesValid = await Promise.all(Object.entries(minimumNonceByAccount).map(async ([account, nonce]) => {
                        const transactionCount = await this.genericProvider.getTransactionCount(account);
                        return nonce >= transactionCount;
                    }));
                    const allNoncesValid = noncesValid.every(Boolean);
                    if (allNoncesValid)
                        return;
                    // target block not yet reached, but nonce has become invalid
                    resolve(FlashbotsBundleResolution.AccountNonceTooHigh);
                }
                else {
                    const block = await this.genericProvider.getBlock(targetBlockNumber);
                    // check bundle against block:
                    const bundleIncluded = transactionAccountNonces.every((transaction, i) => block.transactions[block.transactions.length - 1 - i] === transaction.hash);
                    resolve(bundleIncluded ? FlashbotsBundleResolution.BundleIncluded : FlashbotsBundleResolution.BlockPassedWithoutInclusion);
                }
                if (timer) {
                    clearTimeout(timer);
                }
                if (done) {
                    return;
                }
                done = true;
                this.genericProvider.removeListener('block', handler);
            };
            this.genericProvider.on('block', handler);
            if (typeof timeout === 'number' && timeout > 0) {
                timer = setTimeout(() => {
                    if (done) {
                        return;
                    }
                    timer = null;
                    done = true;
                    this.genericProvider.removeListener('block', handler);
                    reject('Timed out');
                }, timeout);
                if (timer.unref) {
                    timer.unref();
                }
            }
        });
    }
    async simulate(signedBundledTransactions, blockTag, stateBlockTag, blockTimestamp) {
        const blockTagDetails = await this.genericProvider.getBlock(blockTag);
        const blockDetails = blockTagDetails !== null ? blockTagDetails : await this.genericProvider.getBlock('latest');
        const evmBlockNumber = `0x${blockDetails.number.toString(16)}`;
        const evmBlockStateNumber = stateBlockTag !== undefined ? stateBlockTag : `0x${(blockDetails.number - 1).toString(16)}`;
        const evmTimestamp = blockTimestamp !== undefined
            ? blockTimestamp
            : blockTagDetails !== null
                ? blockTagDetails.timestamp
                : await this.extrapolateTimestamp(blockTag, blockDetails);
        const callResult = await this.send('eth_callBundle', [signedBundledTransactions, evmBlockNumber, evmBlockStateNumber, evmTimestamp]);
        return {
            bundleHash: callResult.bundleHash,
            coinbaseDiff: ethers_1.BigNumber.from(callResult.coinbaseDiff),
            results: callResult.results,
            totalGasUsed: callResult.results.reduce((a, b) => a + b.gasUsed, 0)
        };
    }
    async extrapolateTimestamp(blockTag, latestBlockDetails) {
        if (typeof blockTag !== 'number')
            throw new Error('blockTag must be number to extrapolate');
        const blockDelta = blockTag - latestBlockDetails.number;
        if (blockDelta < 0)
            throw new Error('block extrapolation negative');
        return latestBlockDetails.timestamp + blockDelta * SECONDS_PER_BLOCK;
    }
    async fetchReceipts(bundledTransactions) {
        return Promise.all(bundledTransactions.map((bundledTransaction) => this.genericProvider.getTransactionReceipt(bundledTransaction.hash)));
    }
}
exports.FlashbotsBundleProvider = FlashbotsBundleProvider;
//# sourceMappingURL=index.js.map