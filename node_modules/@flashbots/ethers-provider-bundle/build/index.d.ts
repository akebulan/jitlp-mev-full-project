import { BigNumber, providers, Signer } from 'ethers';
import { TransactionRequest, TransactionReceipt } from '@ethersproject/abstract-provider';
import { BaseProvider } from '@ethersproject/providers';
import { ConnectionInfo } from '@ethersproject/web';
import { Networkish } from '@ethersproject/networks';
import { BlockTag } from '@ethersproject/abstract-provider';
export declare const DEFAULT_FLASHBOTS_RELAY = "https://relay.flashbots.net";
export declare enum FlashbotsBundleResolution {
    BundleIncluded = 0,
    BlockPassedWithoutInclusion = 1,
    AccountNonceTooHigh = 2
}
export interface FlashbotsBundleRawTransaction {
    signedTransaction: string;
}
export interface FlashbotsBundleTransaction {
    transaction: TransactionRequest;
    signer: Signer;
}
export interface FlashbotsOptions {
    minTimestamp?: number;
    maxTimestamp?: number;
}
interface TransactionAccountNonce {
    hash: string;
    signedTransaction: string;
    account: string;
    nonce: number;
}
interface FlashbotsTransactionResponse {
    bundleTransactions: Array<TransactionAccountNonce>;
    wait: () => Promise<FlashbotsBundleResolution>;
    simulate: () => void;
    receipts: () => Promise<Array<TransactionReceipt>>;
}
interface TransactionSimulationBase {
    txHash: string;
    gasUsed: number;
}
interface TransactionSimulationSuccess extends TransactionSimulationBase {
    value: string;
}
interface TransactionSimulationRevert extends TransactionSimulationBase {
    error: string;
    revert: string;
}
export declare type TransactionSimulation = TransactionSimulationSuccess | TransactionSimulationRevert;
interface SimulationResponse {
    bundleHash: string;
    coinbaseDiff: BigNumber;
    results: Array<TransactionSimulation>;
    totalGasUsed: number;
}
export declare class FlashbotsBundleProvider extends providers.JsonRpcProvider {
    private genericProvider;
    constructor(genericProvider: BaseProvider, connectionInfoOrUrl: ConnectionInfo, network: Networkish);
    static throttleCallback(): Promise<boolean>;
    static create(genericProvider: BaseProvider, flashbotsKeyId: string, flashbotsSecret: string, connectionInfoOrUrl?: ConnectionInfo | string, network?: Networkish): Promise<FlashbotsBundleProvider>;
    sendRawBundle(signedBundledTransactions: Array<string>, targetBlockNumber: number, opts?: FlashbotsOptions): Promise<FlashbotsTransactionResponse>;
    sendBundle(bundledTransactions: Array<FlashbotsBundleTransaction | FlashbotsBundleRawTransaction>, targetBlockNumber: number, opts?: FlashbotsOptions): Promise<FlashbotsTransactionResponse>;
    signBundle(bundledTransactions: Array<FlashbotsBundleTransaction | FlashbotsBundleRawTransaction>): Promise<Array<string>>;
    private wait;
    simulate(signedBundledTransactions: Array<string>, blockTag: BlockTag, stateBlockTag?: BlockTag, blockTimestamp?: number): Promise<SimulationResponse>;
    private extrapolateTimestamp;
    private fetchReceipts;
}
export {};
